{% extends "partials/base.html" %}

{% block title %}Clustering{% endblock %}

{% block content %}
<div class="container mt-4">
  <h2>Clustering 3D avec Bounding Boxes</h2>
  
  <form id="clusterForm" class="mb-3">
    <label for="filename">Choisir un fichier :</label>
    <select id="filename" class="form-control">
      {% for file in files %}
        <option value="{{ file }}">{{ file }}</option>
      {% endfor %}
    </select>
    <button type="button" class="btn btn-primary mt-2" onclick="startClustering()">Lancer le clustering</button>
  </form>

  <div id="viewer" style="width: 100%; height: 600px; background: #000;"></div>
</div>

<!-- Three.js & OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
let scene, camera, renderer, controls;

function initViewer() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000);
  camera.position.set(0, 0, 10);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, 600);
  document.getElementById("viewer").appendChild(renderer.domElement);

  // âœ… Ajouter OrbitControls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.update();

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function drawClusteredPointCloud(clustersData) {
  // ðŸ§¹ Nettoyer la scÃ¨ne
  while (scene.children.length > 0) {
    scene.remove(scene.children[0]);
  }

  clustersData.forEach(cluster => {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(cluster.points.flat());
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({ size: 0.05, color: Math.random() * 0xffffff });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // ðŸ”² Bounding box
    const min = new THREE.Vector3(...cluster.bbox.min);
    const max = new THREE.Vector3(...cluster.bbox.max);
    const box = new THREE.Box3(min, max);
    const helper = new THREE.Box3Helper(box, new THREE.Color(0xff0000));
    scene.add(helper);
  });
}

function startClustering() {
  const filename = document.getElementById("filename").value;
  fetch(`/cluster/${filename}`)
    .then(res => {
      if (!res.ok) throw new Error(`Erreur serveur (${res.status})`);
      return res.json();
    })
    .then(data => {
      if (data.clusters) {
        drawClusteredPointCloud(data.clusters);
      } else {
        alert("Erreur API : " + data.error);
      }
    })
    .catch(err => {
      alert("Erreur JSON : " + err.message);
      console.error(err);
    });
}

window.onload = initViewer;
</script>
{% endblock %}
