{% extends "partials/base.html" %}

{% block content %}
<div class="container mt-4">
  <h2>Prétraitement des Données LiDAR</h2>
  <form id="preprocess-form" class="mt-4">
    <div class="mb-3">
      <label for="file-select" class="form-label">Sélectionner un fichier :</label>
      <select id="file-select" class="form-select" name="filename" required>
        {% for file in files %}
        <option value="{{ file }}">{{ file }}</option>
        {% endfor %}
      </select>
    </div>

    <div class="mb-3">
      <label for="step-select" class="form-label">Étape de prétraitement :</label>
      <select id="step-select" class="form-select" name="step" required>
        <option value="remove_top_bottom">Suppression haut/bas</option>
        <option value="remove_side_points">Suppression côtés</option>
        <option value="remove_outliers">Suppression outliers</option>
        <option value="remove_floor">Suppression sol</option>
        <option value="downsample">Downsampling</option>
      </select>
    </div>

    <button type="submit" class="btn btn-primary">Appliquer le prétraitement</button>
    <button type="button" id="run-pipeline-btn" class="btn btn-warning mt-2">
      Appliquer toute la pipeline
    </button>
    
    <button type="button" id="download-btn" class="btn btn-success ms-2" style="display: none;">Télécharger</button>
  </form>

  <div class="mt-3">
    <p><strong>Points avant :</strong> <span id="count-before">-</span></p>
    <p><strong>Points après :</strong> <span id="count-after">-</span></p>
  </div>

  <h4 class="mt-4">Résultat :</h4>
  <div id="viewer" style="width: 100%; height: 500px;"></div>
</div>

<!-- Librairies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

<script>
  const form = document.getElementById("preprocess-form");
  const downloadBtn = document.getElementById("download-btn");
  const countBefore = document.getElementById("count-before");
  const countAfter = document.getElementById("count-after");

  let latestFilename = "";
  let pointCloud, material;

  form.addEventListener("submit", async function (e) {
    e.preventDefault();
    const filename = document.getElementById("file-select").value;
    const step = document.getElementById("step-select").value;

    const response = await fetch(`/preprocess_step_and_return_json/${step}/${filename}`);
    const result = await response.json();

    if (result.error) {
      alert("Erreur: " + result.error);
      return;
    }

    const formattedPoints = result.points.map(p => ({ x: p[0], y: p[1], z: p[2] }));

    countBefore.textContent = result.points_before ?? "N/A";
    countAfter.textContent = formattedPoints.length;

    latestFilename = result.filename;
    downloadBtn.style.display = "inline-block";

    visualizePointCloud(formattedPoints);
  });

  downloadBtn.addEventListener("click", () => {
    if (latestFilename) {
      window.location.href = `/uploads/processed/${latestFilename}`;
    }
  });

  let scene, camera, renderer, controls;
  initViewer();

  function initViewer() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / 500, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, 500);

    const container = document.getElementById("viewer");
    container.innerHTML = "";
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 0, 5);
    controls.update();

    // Ajout axes + grille
    const axesHelper = new THREE.AxesHelper(1);
    const gridHelper = new THREE.GridHelper(10, 10);
    scene.add(axesHelper);
    scene.add(gridHelper);

    animate();

    // Contrôles GUI
    const gui = new dat.GUI();
    const settings = {
      pointSize: 0.05,
      color: "#00ffff",
      bgColor: "#000000",
      showAxes: true,
      showGrid: true,
      resetCamera: () => {
        camera.position.set(0, 0, 5);
        controls.update();
      }
    };

    gui.add(settings, "pointSize", 0.01, 1).onChange(() => {
      if (material) material.size = settings.pointSize;
    });
    gui.addColor(settings, "color").onChange(() => {
      if (material) material.color.set(settings.color);
    });
    gui.addColor(settings, "bgColor").onChange(() => {
      renderer.setClearColor(settings.bgColor);
    });
    gui.add(settings, "showAxes").onChange(v => axesHelper.visible = v);
    gui.add(settings, "showGrid").onChange(v => gridHelper.visible = v);
    gui.add(settings, "resetCamera");
  }

  function visualizePointCloud(points) {
    while (scene.children.length > 2) { // keep grid + axes
      scene.remove(scene.children[scene.children.length - 1]);
    }

    const geometry = new THREE.BufferGeometry();
    const vertices = [];

    points.forEach(p => {
      vertices.push(p.x, p.y, p.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    material = new THREE.PointsMaterial({ size: 0.05, color: 0x00ffff });
    pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
</script>
{% endblock %}
